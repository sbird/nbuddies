from __future__ import annotations
from .BlackHoles_Struct import BlackHole
import numpy as np

class Node():
    def __init__(self, bounds : list[list[float : 2] : 3], enclosed_blackholes : list[BlackHole] = np.empty(0)):
        """
        Initializes node and checks some basic assertions

        Parameters
        ----------
        bounds : list[list[float : 2] : 3]
            boundaries of the node
        enclosed_blackholes : list[Blackhole], default []
            the blackholes enclosed in the node

        Returns
        -------
        Node
            The initialized node
        """
        self.MAX_CHILDREN = 8 # cubic lattice
        self.children = np.empty(self.MAX_CHILDREN, dtype=Node)

        self.bounds = np.array(bounds)
        assert self.bounds[0,1] > self.bounds[0,0], "x_max < x_min in node bounds"
        assert self.bounds[1,1] > self.bounds[1,0], "y_max < y_min in node bounds"
        assert self.bounds[2,1] > self.bounds[2,0], "z_max < z_min in node bounds"

        self.crossection = np.linalg.norm([b[1] - b[0] for b in self.bounds])
        
        self.enclosed_blackholes = np.array(enclosed_blackholes)
        for bh in enclosed_blackholes:
            assert self.is_inside(bh.position), f"black hole not enclosed in node x: {bh.position} outside {self.bounds}"
        
        self.mass = None
        self.center_of_mass = None

    position = property(
        fget = lambda self : self.center_of_mass,
        doc = "returns center of mass when position is called upon to work as drop in for blackhole"
    )
    
    def is_inside(self, position : list[float]):
        """
        Returns if position is inside the node
        
        Parameters
        ----------
        position : list[float]
            the position to be checked

        Returns
        -------
        bool
            whether or not it's inside
        """
        for i in range(3):
            if position[i] < self.bounds[i,0] or position[i] > self.bounds[i,1]:
                return False
        
        return True
    
    def add_child(self, child : Node):
        """
        Attempts to add child and errors if node is already full

        Parameters
        ----------
        child : Node
            the child to be added
        """
        i=0
        while i < self.MAX_CHILDREN and self.children[i] is not None:
            i+=1

        assert i < self.MAX_CHILDREN, "Attempting to add child to full node"

        self.children[i] = child

    def add_blackhole(self, bh : BlackHole):
        """
        Attempts to add black hole errors if outside of node

        Parameters
        ----------
        bh : BlackHole
            black hole to be added
        """
        assert self.is_inside(bh.position), f"black hole not enclosed in node x: {bh.position} outside {self.bounds}"

        self.enclosed_blackholes = np.append(self.enclosed_blackholes, bh)

    def has_children(self):
        """
        determines if this node has children based on knowledge nodes with less than 2 bhs will not be given children when the tree is initialized

        Returns
        -------
        bool
            whether or not the node has children
        """
        return len(self.enclosed_blackholes) > 1

    def _add_to_visualization_string(self, preface):
        """
        Generates string visualization for this branch and it's children

        Parameters
        ----------
        preface : string
            the preamble to go before each line in this string generated by this function

        Returns
        ------- 
        string
            visualization of this branch and it's children
        """
        visualized_tree_string = ""
        
        for i in range(self.MAX_CHILDREN):
            visualized_tree_string += preface
            if not self.children[i].has_children():
                visualized_tree_string += f"\t\t|-leaf %03d \n" % len(self.children[i].enclosed_blackholes)
            else:
                visualized_tree_string += f"\t\t|-branch %03d ---| \n" % len(self.children[i].enclosed_blackholes)
                if i == self.MAX_CHILDREN - 1:
                    visualized_tree_string += self.children[i]._add_to_visualization_string(preface + "\t\t ")
                else:
                    visualized_tree_string += self.children[i]._add_to_visualization_string(preface + "\t\t|")

        return visualized_tree_string

    def __str__(self):
        """
        Generates string visualization of tree

        Returns
        -------
        string
            visualization of tree structure as a string
        """
        visualized_tree_string = f"Root %03d -------| \n" % len(self.enclosed_blackholes)
        for i in range(self.MAX_CHILDREN):
            if not self.children[i].has_children():
                visualized_tree_string += f"\t\t|-leaf %03d \n" % len(self.children[i].enclosed_blackholes)
            else:
                visualized_tree_string += f"\t\t|-branch %03d ---| \n"% len(self.children[i].enclosed_blackholes)
                if i == self.MAX_CHILDREN - 1:
                    visualized_tree_string += self.children[i]._add_to_visualization_string("\t\t ")
                else:
                    visualized_tree_string += self.children[i]._add_to_visualization_string("\t\t|")

        return visualized_tree_string

def build_tree(blackholes : list[BlackHole]):
    """
    builds the gravitree for a list of blackholes, root node is centered on mean position with bounds than include all blackholes

    Parameters
    ----------
    blackholes : list[BlackHole]
        list of blackholes to build the tree out of

    Returns
    -------
    Node
        Root node of the gravitree
    """
    center = [
        np.mean([bh.position[0] for bh in blackholes]),
        np.mean([bh.position[1] for bh in blackholes]),
        np.mean([bh.position[2] for bh in blackholes]),
    ]
    box_radii = np.array([
        np.max([np.abs(bh.position[0] - center[0]) for bh in blackholes]),
        np.max([np.abs(bh.position[1] - center[1]) for bh in blackholes]),
        np.max([np.abs(bh.position[2] - center[2]) for bh in blackholes])
    ])
    #enfoce cubic lattice
    box_radius = np.max(box_radii)
    # pad radii to prevent floating point error from making an extremal bh fall outside the box
    box_radius *= 1.1
    global_bounds = [
        [center[0] - box_radius, center[0] + box_radius],
        [center[1] - box_radius, center[1] + box_radius],
        [center[2] - box_radius, center[2] + box_radius],
    ]

    root = Node(global_bounds, blackholes)

    _initalize_tree(root)
    _compute_node_tree(root)

    return root

def _initalize_tree(root : Node):
    """
    Recursively generates the entire tree by returning this node immediately if there's less than 2 black holes and populating this nodes 8 children then calling this funciton on them otherwise

    Parameters
    ----------
    root : Node
        the root node to generate the tree from
    """
    if len(root.enclosed_blackholes) <= 1:
        return
    
    center = [
        (root.bounds[0,0] + root.bounds[0,1])/2,
        (root.bounds[1,0] + root.bounds[1,1])/2,
        (root.bounds[2,0] + root.bounds[2,1])/2
    ]

    #indices correspond to octants gray code labels
    children = np.array([
        #0 +++
        Node([
            [center[0], root.bounds[0,1]],
            [center[1], root.bounds[1,1]],
            [center[2], root.bounds[2,1]]
        ]),
        #1 -++
        Node([
            [root.bounds[0,0], center[0]],
            [center[1], root.bounds[1,1]],
            [center[2], root.bounds[2,1]]
        ]),
        #2 --+
        Node([
            [root.bounds[0,0], center[0]],
            [root.bounds[1,0], center[1]],
            [center[2], root.bounds[2,1]]
        ]),
        #3 +-+
        Node([
            [center[0], root.bounds[0,1]],
            [root.bounds[1,0], center[1]],
            [center[2], root.bounds[2,1]]
        ]),
        #4 +--
        Node([
            [center[0], root.bounds[0,1]],
            [root.bounds[1,0], center[1]],
            [root.bounds[2,0], center[2]]
        ]),
        #5 ---
        Node([
            [root.bounds[0,0], center[0]],
            [root.bounds[1,0], center[1]],
            [root.bounds[2,0], center[2]]
        ]),
        #6 -+-
        Node([
            [root.bounds[0,0], center[0]],
            [center[1], root.bounds[1,1]],
            [root.bounds[2,0], center[2]]
        ]),
        #7 ++-
        Node([
            [center[0], root.bounds[0,1]],
            [center[1], root.bounds[1,1]],
            [root.bounds[2,0], center[2]]
        ])
    ])

    #populating nodes with black holes
    for bh in root.enclosed_blackholes:
        if bh.position[0] > center[0]:
            if bh.position[1] > center[1]:
                if bh.position[2] > center[2]:
                    #+++
                    children[0].add_blackhole(bh)
                else:
                    #++-
                    children[7].add_blackhole(bh)
            else:
                if bh.position[2] > center[2]:
                    #+-+
                    children[3].add_blackhole(bh)
                else:
                    #+--
                    children[4].add_blackhole(bh)
        else:
            if bh.position[1] > center[1]:
                if bh.position[2] > center[2]:
                    #-++
                    children[1].add_blackhole(bh)
                else:
                    #-+-
                    children[6].add_blackhole(bh)
            else:
                if bh.position[2] > center[2]:
                    #--+
                    children[2].add_blackhole(bh)
                else:
                    #---
                    children[5].add_blackhole(bh)

    #attach children
    root.children = children

    #build branches for children
    for node in root.children:
        _initalize_tree(node)

def _compute_node_tree(root : Node):
    """
    Computes the mass and center of mass for whole tree starting from leaves and utilizing the fact that a center of mass of center of masses is the overall center of mass to avoid repeat calculation as it works back up the tree

    Parameters
    ----------
    root : Node
        root node of the tree
    """
    root.mass = 0.0
    root.center_of_mass = np.zeros(3)
    root.velocity = np.zeros(3)
    root.acceleration = np.zeros(3)
    if root.has_children():
        for child in root.children:
            if child.mass is None:
                _compute_node_tree(child)
            root.mass += child.mass
            root.center_of_mass += child.mass * child.center_of_mass
            root.velocity += child.mass * child.velocity
            root.acceleration += child.mass * child.acceleration
        if root.mass != 0:
            root.center_of_mass /= root.mass
            root.velocity /= root.mass
            root.acceleration /= root.mass
    else:
        for bh in root.enclosed_blackholes:
            root.mass += bh.mass
            root.center_of_mass += bh.mass * bh.position
            root.velocity += bh.mass * bh.velocity
            root.acceleration += bh.mass * bh.acceleration
        if root.mass != 0:
            root.center_of_mass /= root.mass
            root.velocity /= root.mass
            root.acceleration /= root.mass
